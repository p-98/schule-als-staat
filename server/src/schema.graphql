" For file uploads; automatically handled by graphql-yoga "
scalar File
" For void returns, handled by graphql-scalars "
scalar Void
" For RFC 3339 datetime strings, handled by graphql-scalars "
scalar DateTime

" requires ONE of the roles provided to be present on the current loged in user "
directive @auth(role: [AuthRole!] = [ADMIN]) on FIELD_DEFINITION | OBJECT

#            #
# Enum types #
#            #

" Roles used for authorization "
enum AuthRole {
    ADMIN
    USER
    CITIZEN
    COMPANY
    GUEST
    POLICE
    BANK
    BORDER_CONTROL
    POLITICS
}

" type of user "
enum UserType {
    CITIZEN
    COMPANY
    GUEST
}

" state of employment offer "
enum EmploymentOfferState {
    PENDING
    REJECTED
}
" state of employment offer available to citizens "
enum EmploymentOfferStateCitizenInput {
    PENDING
}
" state of employment offer available to companies "
enum EmploymentOfferStateCompanyInput {
    PENDING
    REJECTED
}

" change action types "
enum ChangeTransactionAction {
    VIRTUAL_TO_REAL
    REAL_TO_VIRTUAL
}

" action of BorderCrossing "
enum BorderCrossingAction {
    ENTER
    LEAVE
}

" type of vote "
enum VoteType {
    CONSENSUS
    RADIO
}

#                        #
# Object and Union types #
#                        #

" Ein Buch " # eslint-disable-next-line @graphql-eslint/strict-id-in-types
type Book {
    title: String!
    author: Author!
}

" Ein Author " # eslint-disable-next-line @graphql-eslint/strict-id-in-types
type Author {
    name: String!
    books: [Book!]!
}

" The current session "
type Session {
    id: ID!
    user: User
}

" Base type for users "
interface User {
    id: ID!

    balance: Float!
    " amount of virtual money that can be changed back to real money "
    redemptionBalance: Float!
    transactions: [Transaction!]!
}
" A guest user "
type GuestUser implements User {
    id: ID!
    balance: Float!
    " amount of virtual money that can be changed back to real money "
    redemptionBalance: Float!
    transactions: [Transaction!]!
    name: String
    enteredAt: DateTime!
    leftAt: DateTime
}
" A citizen user "
type CitizenUser implements User {
    id: ID!
    balance: Float!
    " amount of virtual money that can be changed back to real money "
    redemptionBalance: Float!
    transactions: [Transaction!]!
    firstName: String!
    lastName: String!
    image: String!
    employment: Employment
    employmentOffers(
        state: EmploymentOfferStateCitizenInput! = PENDING
    ): [EmploymentOffer!]!
}
" A company user "
type CompanyUser implements User {
    id: ID!
    balance: Float!
    " amount of virtual money that can be changed back to real money "
    redemptionBalance: Float!
    transactions: [Transaction!]!
    drafts: [Draft!]!
    name: String!
    image: String!
    products: [Product!]!
    employer: Employment!
    employees: [Employment!]!
    employmentOffers(
        state: EmploymentOfferStateCompanyInput!
    ): [EmploymentOffer!]!
    stats: [CompanyStatsFragment!]!
}
" Representing a 1h timeframe of the company's stats "
type CompanyStatsFragment {
    startOfHour: DateTime!
    staff: Float!
    staffCost: Float!
    grossRevenue: Float!
    netRevenue: Float!
    profit: Float!
}

" Information about a shift on an employee "
type Worktime {
    id: ID!
    employment: Employment!
    start: DateTime!
    " If null, the shift has not yet ended "
    end: DateTime
}

" Contains information about an employment "
type Employment {
    id: Int!
    company: CompanyUser!
    citizen: CitizenUser!

    # dynamic values
    " in seconds "
    worktimeToday: Int!
    " in seconds "
    worktimeYesterday: Int!

    # contract (static values)
    " virtual currency per hour (employment contract) "
    salary: Float!
    " worktime per day in seconds (employment contract) "
    minWorktime: Int!
}
" A employment offer "
type EmploymentOffer {
    id: Int!
    company: CompanyUser!
    citizen: CitizenUser!
    state: EmploymentOfferState!
    " virtual currency per hour "
    salary: Float!
    " worktime per day in seconds "
    minWorktime: Int!
}

" Base type for transactions"
interface Transaction {
    id: Int!
    date: DateTime!
}
" Base type for transaction drafts "
interface Draft {
    id: Int!
    date: DateTime!
}
" A transfer transaction "
type TransferTransaction implements Transaction {
    id: Int!
    date: DateTime!
    sender: User!
    receiver: User!
    value: Float!
    purpose: String
}
" A change transaction "
type ChangeTransaction implements Transaction {
    id: Int!
    date: DateTime!
    user: User!
    action: ChangeTransactionAction!
    valueVirtual: Float!
    valueReal: Float!
}
" The draft of a change transaction "
type ChangeDraft implements Draft {
    id: Int!
    date: DateTime!
    action: ChangeTransactionAction!
    valueVirtual: Float!
    valueReal: Float!
}
" Input type of a change transaction "
input ChangeInput {
    action: ChangeTransactionAction!
    " value in the currency from which is changed "
    value: Float!
}
" A purchase transaction "
type PurchaseTransaction implements Transaction {
    id: Int!
    date: DateTime!
    customer: User!
    company: CompanyUser!
    grossPrice: Float!
    netPrice: Float!
    tax: Float!
    items: [PurchaseItem!]!
    discount: Float
}
" The draft of a purchase transaction "
type PurchaseDraft implements Draft {
    id: Int!
    date: DateTime!
    company: CompanyUser!
    grossPrice: Float!
    netPrice: Float!
    tax: Float!
    items: [PurchaseItem!]!
    discount: Float!
}
" Input type of a purchase transaction "
input PurchaseInput {
    items: [PurchaseItemInput!]!
    discount: Float
}
" Tuple with product and amount for use in purchases " # eslint-disable-next-line @graphql-eslint/strict-id-in-types
type PurchaseItem {
    product: Product!
    amount: Int!
}
" Tuple with product and amount for use in purchases "
input PurchaseItemInput {
    productId: ID!
    amount: Int!
}
" A customs transaction "
type CustomsTransaction implements Transaction {
    id: Int!
    date: DateTime!
    user: User!
    customs: Float!
}
" Input type for customs transaction "
input CustomsInput {
    user: UserSignatureInput!
    customs: Float!
}
" A salary transaction "
type SalaryTransaction implements Transaction {
    id: Int!
    date: DateTime!
    employment: Employment!
    grossValue: Float!
    netValue: Float!
    tax: Float!
    " If null, it is a bonus payment "
    worktime: Worktime
    isBonus: Boolean!
}

" return type for registerBorderCrossing mutation " # eslint-disable-next-line @graphql-eslint/strict-id-in-types
type BorderCrossing {
    citizen: CitizenUser!
    action: BorderCrossingAction!
    date: DateTime!
}

" A product of an company "
type Product {
    id: ID!
    revision: ID!
    company: CompanyUser!
    name: String!
    price: Float!
    deleted: Boolean!
    salesToday: Int!
    salesTotal: Int!
    salesPerDay: Float!
    grossRevenueTotal: Float!
    stats: [ProductStatsFragment!]!
}
" Input type for Product "
input ProductInput {
    name: String!
    price: Float!
}
" Representing a 1h timeframe of the product's stats"
type ProductStatsFragment {
    startOfHour: DateTime!
    sales: Int!
    grossRevenue: Float!
}

" Contains information about a user vote "
type VoteCitizenEdge {
    user: CitizenUser!
    vote: [Float!]!
}
" A vote "
type Vote {
    id: ID!
    type: VoteType!
    title: String!
    description: String!
    image: String!
    endAt: DateTime!
    choices: [String!]!
    result: [Float!]
    chartInfo: String
    # eslint-disable-next-line @graphql-eslint/no-typename-prefix
    votes: [VoteCitizenEdge!]!
}

#             #
# Input types #
#             #

" Input for addBook mutation "
input AddBookInput {
    title: String!
    author: String!
}

" Information needed to identify a user "
input UserSignatureInput {
    type: UserType!
    id: String!
}
" Information to authenticate a user "
input CredentialsInput {
    type: UserType!
    id: ID!
    password: String
}

" Input for createEmploymentOffer mutation "
input CreateEmploymentOfferInput {
    citizenId: ID!
    " virtual currency per hour "
    salary: Float!
    " worktime per day in seconds "
    minWorktime: Int!
}

" Input for transferMoney mutation "
input TransferTransactionInput {
    " receiver must be a citizen "
    receiver: UserSignatureInput!
    value: Float!
    purpose: String
}
" Input for warehousePurchase mutation "
input WarehousePurchaseTransactionInput {
    items: [PurchaseItemInput!]!
}

" Input for createGuest mutation "
input CreateGuestInput {
    cardId: ID!
    name: String
}

" Input for createVote mutation "
input CreateVoteInput {
    type: VoteType!
    title: String!
    description: String!
    image: File!
    endAt: DateTime!
    choices: [String!]!
}
" Input for vote mutation "
input VoteInput {
    voteId: ID!
    vote: [Float!]!
}

#                #
# API Root types #
#                #

" Queries "
type Query {
    books: [Book!]!
    book(title: String!): Book

    authors: [Author!]!
    author(name: String!): Author

    " for debugging only "
    session: Session! @auth(role: [ADMIN])
    me: User! @auth(role: [USER])
    meGuest: GuestUser! @auth(role: [GUEST])
    meCitizen: CitizenUser! @auth(role: [CITIZEN])
    meCompany: CompanyUser! @auth(role: [COMPANY])

    votes: [Vote!]!

    userFromCard(cardId: ID!): User!
}

" Mutations "
type Mutation {
    addBook(input: AddBookInput!): Book!

    " login as user; guests don't need a password "
    login(user: UserSignatureInput!, password: String): User!
    logout: Void

    createEmploymentOffer(offer: CreateEmploymentOfferInput!): EmploymentOffer!
        @auth(role: [COMPANY])
    acceptEmploymentOffer(id: Int!): Employment! @auth(role: [CITIZEN])
    rejectEmploymentOffer(id: Int!, reason: String): EmploymentOffer!
        @auth(role: [CITIZEN])
    " offer must be rejected to be deleted "
    deleteEmploymentOffer(id: Int!): Void @auth(role: [COMPANY])
    cancelEmployment(id: Int!): Void @auth(role: [CITIZEN, COMPANY])

    payBonus(value: Float!, employmentIds: [Int!]!): [SalaryTransaction!]!
        @auth(role: [COMPANY])
    changeCurrencies(change: ChangeInput!): ChangeDraft! @auth(role: [BANK])
    " Pay a change transaction draft. Only bank must specify explicit user. "
    payChangeDraft(id: Int!, credentials: CredentialsInput): ChangeTransaction!
        @auth(role: [USER])
    deleteChangeDraft(id: Int!): Void @auth(role: [BANK])
    transferMoney(transfer: TransferTransactionInput!): TransferTransaction!
        @auth(role: [CITIZEN])

    sell(purchase: PurchaseInput!): PurchaseDraft! @auth(role: [COMPANY])
    " Pay a change transaction draft. Only selling company must specify explicit user. "
    payPurchaseDraft(
        id: Int!
        credentials: CredentialsInput
    ): PurchaseTransaction!
    deletePurchaseDraft(id: Int!): Void

    warehousePurchase(
        purchase: WarehousePurchaseTransactionInput!
    ): PurchaseTransaction! @auth(role: [COMPANY])
    chargeCustoms(customs: CustomsInput!): CustomsTransaction!
        @auth(role: [BORDER_CONTROL])

    registerBorderCrossing(citizenId: ID!): BorderCrossing!
        @auth(role: [BORDER_CONTROL])

    createGuest(guest: CreateGuestInput!): GuestUser!
        @auth(role: [BORDER_CONTROL])
    removeGuest(cardId: ID!): Void @auth(role: [BORDER_CONTROL])

    addProduct(product: ProductInput!): Product! @auth(role: [COMPANY])
    editProduct(id: ID!, product: ProductInput!): Product!
        @auth(role: [COMPANY])
    " remove product from the company's inventory "
    removeProduct(id: ID!): Void @auth(role: [COMPANY])

    createVote(vote: CreateVoteInput!): Vote! @auth(role: [POLITICS])
    vote(vote: VoteInput!): VoteCitizenEdge! @auth(role: [CITIZEN])
}

" Subscriptions "
type Subscription {
    addedBook(author: String): Book!
}
